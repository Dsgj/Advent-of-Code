<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advent of Code - Day 01 - Secret Entrance</title>
    <link rel="stylesheet" href="../common.css">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header class="page-header">
        <div class="header-row">
            <a href="../index.html" class="home-link">‚Üê Calendar</a>
            <div class="header-center">
                <h1>üîê SECRET VAULT CRACKER üîê</h1>
                <p class="subtitle">Day 1 - HQ Coordinate Triangulation System</p>
            </div>
            <div class="header-right">
                <div class="status-panel-header">
                    <div class="status-light" id="statusLight"></div>
                    <span class="status-text text-glow" id="statusText">LOCKED</span>
                </div>
            </div>
        </div>
        <div class="header-controls">
            <button id="part1Btn" class="active">Part 1</button>
            <button id="part2Btn">Part 2</button>
            <button id="inputBtn">‚å® Input <span id="inputBadge" class="input-badge">EX</span></button>
        </div>
    </header>

    <div class="container">
        <div class="main-content">
            <div class="safe-body">
                <div class="dial-container" id="dialContainer">
                    <div class="dial-outer">
                        <div class="indicator"></div>
                    </div>
                    <div class="dial" id="dial">
                        <div class="dial-face" id="dialFace"></div>
                    </div>
                    <div class="center-hub"></div>
                </div>
            </div>

            <div class="sidebar">
                <div class="stats-panel">
                    <div class="panel-title">Current</div>
                    <div class="stat-row">
                        <span class="stat-label">Instruction</span>
                        <span class="stat-value" id="instruction">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Position</span>
                        <span class="stat-value" id="position">50</span>
                    </div>
                </div>

                <div class="stats-panel result-panel">
                    <div class="panel-title" id="resultLabel">Part 1 Result</div>
                    <div class="result-value" id="resultValue">0</div>
                </div>

                <div class="stats-panel">
                    <div class="panel-title">Controls</div>
                    <div class="control-buttons">
                        <button id="runBtn">‚ñ∂ Run</button>
                        <button id="stepBtn">‚è≠ Step</button>
                        <button id="resetBtn">üîÑ Reset</button>
                    </div>
                    <div class="speed-control">
                        <label>Speed</label>
                        <input type="range" id="speed" min="10" max="500" value="200">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="../common.js"></script>
    <script>
        const dial = document.getElementById('dial');
        const dialFace = document.getElementById('dialFace');
        const dialContainer = document.getElementById('dialContainer');
        const positionEl = document.getElementById('position');
        const resultValueEl = document.getElementById('resultValue');
        const resultLabelEl = document.getElementById('resultLabel');
        const instructionEl = document.getElementById('instruction');
        const runBtn = document.getElementById('runBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedSlider = document.getElementById('speed');
        const inputBtn = document.getElementById('inputBtn');
        const part1Btn = document.getElementById('part1Btn');
        const part2Btn = document.getElementById('part2Btn');

        let currentPart = 1; // Track which part is selected

        const exampleData = `L68
L30
R48
L5
R60
L55
L1
L99
R14
L82`;

        // Initialize Global Input Modal
        Common.setupInputModal({
            placeholder: 'L5, R1, R3, L9...',
            storageKey: 'day1_custom_input',
            exampleInput: exampleData,
            onLoad: (data) => {
                currentInput = data;
                parseInstructions();
                reset(); // Reset applies the new input
            }
        });

        // Current input managed by Load callback, but need initial state
        let currentInput = Common.getInput('day1_custom_input', exampleData);

        let position = 50;
        let part1Count = 0;
        let part2Count = 0;
        let instructions = [];
        let currentIndex = 0;
        let isRunning = false;
        let isPaused = false;
        let isExecuting = false;
        let stepOnce = false;
        let fastMode = false;  // Flag for fast 0.1s animation

        function createDialNumbers() {
            const faceCenter = 115;

            for (let i = 0; i < 100; i++) {
                // Dial rotates, so position numbers relative to dial, not screen
                const angle = (i * 3.6 - 90) * Math.PI / 180;

                // Add tick marks
                const tick = document.createElement('div');
                tick.className = 'dial-tick' + (i % 5 === 0 ? ' major' : '');
                tick.style.left = `${faceCenter}px`;
                tick.style.top = '10px';
                tick.style.transform = `rotate(${i * 3.6}deg)`;
                dialFace.appendChild(tick);

                // Add numbers every 5
                if (i % 5 === 0) {
                    const radius = 85;
                    const x = faceCenter + radius * Math.cos(angle);
                    const y = faceCenter + radius * Math.sin(angle);
                    const rotationAngle = i * 3.6; // Rotate number to point outward

                    const numEl = document.createElement('div');
                    numEl.className = 'dial-number' + (i === 0 ? ' zero' : '');
                    numEl.textContent = i;
                    numEl.style.left = `${x}px`;
                    numEl.style.top = `${y}px`;
                    numEl.style.transform = `translate(-50%, -50%) rotate(${rotationAngle}deg)`;
                    numEl.id = `num-${i}`;
                    dialFace.appendChild(numEl);
                }
            }
        }

        function updateDial() {
            // Rotate the dial so current position aligns with top indicator
            // Use currentRotation to support smooth multi-turn animations
            dial.style.transform = `rotate(${currentRotation}deg)`;
            positionEl.textContent = position;

            // Update highlighting
            document.querySelectorAll('.dial-number').forEach(el => {
                el.classList.remove('current');
            });
            const nearestFive = Math.round(position / 5) * 5 % 100;
            const numEl = document.getElementById(`num-${nearestFive}`);
            if (numEl && Math.abs(position - nearestFive) <= 2) {
                numEl.classList.add('current');
            }
        }

        function parseInstructions() {
            const text = currentInput.trim();
            instructions = text.split(/\r?\n/).filter(line => line.trim()).map(line => line.trim().replace(/,$/, ''));
            // Handle comma separated if user pastes single line
            if (instructions.length === 1 && instructions[0].includes(',')) {
                instructions = instructions[0].split(',').map(s => s.trim());
            }
            currentIndex = 0;

            // Initial instruction display
            instructionEl.textContent = '-';
        }

        function reset() {
            position = 50;
            part1Count = 0;
            part2Count = 0;
            currentIndex = 0;
            isRunning = false;
            currentRotation = -180; // Reset rotation so it doesn't spin wildly

            // Re-parse current input to ensure we start fresh
            parseInstructions();

            updateDial();
            updateResult();

            // Reset status text via DOM if it existed, but we may have removed it?
            // Checking original file... statusTextEl was declared.
            // HTML didn't show statusTextEl in viewed lines, but line 102 queried it?
            // Ah, line 102: const statusTextEl = document.getElementById('statusText');
            // But I removed the loop that was creating it? No, that was Dial Numbers.
            // Wait, where is statusTextEl in HTML? Not in lines 1-76 of viewed file.
            // It might be missing or I missed it.
            // In reset() original: statusTextEl.textContent = 'Ready';
            // If it doesn't exist, this will error.
            // Checking lines 43-73 (Sidebar)... Status Panel (Current) has instruction and position.
            // No statusText.
            // I will remove statusTextEl reference to be safe or check if it exists.
            // It was likely in line 102.

            runBtn.disabled = false;
            stepBtn.disabled = false;
            runBtn.textContent = '‚ñ∂ Run';
            updateStatus(currentPart === 1 ? "VAULT LOCKED" : "ELEVATOR READY", 'ready');
        }

        function updateStatus(text, state) {
            const statusText = document.getElementById('statusText');
            const statusLight = document.getElementById('statusLight');
            if (statusText && statusLight) {
                statusText.textContent = text;
                statusLight.className = 'status-light ' + state;
            }
        }

        function updateResult() {
            resultValueEl.textContent = currentPart === 1 ? part1Count : part2Count;
            resultLabelEl.textContent = `Part ${currentPart} Result`;
        }

        // Part toggle handlers
        part1Btn.addEventListener('click', () => {
            currentPart = 1;
            part1Btn.classList.add('active');
            part2Btn.classList.remove('active');
            updateResult();
            reset();
        });

        part2Btn.addEventListener('click', () => {
            currentPart = 2;
            part2Btn.classList.add('active');
            part1Btn.classList.remove('active');
            updateResult();
            reset();
        });

        let currentRotation = -180; // Starting at 50 (-180deg) matches initial position

        async function executeInstruction(inst) {
            const direction = inst[0];
            const amount = parseInt(inst.substring(1));
            instructionEl.textContent = inst;

            // Math Optimization (matches solution.ts)
            // Instead of simulating ticks, calculate valid zero-crossings directly

            let passesZero = 0;
            // Note: In solution.ts, logic handles 0-99 range naturally.
            // Current position 0-99.

            if (direction === 'R') {
                passesZero = Math.floor((position + amount) / 100);
                position = (position + amount) % 100;
                // Accumulate rotation: Increasing position means rotating dial CCW (negative)
                currentRotation -= amount * 3.6;
            } else if (direction === 'L') {
                // ... (simplified logic)
                if (position < amount) {
                    passesZero = 1 + Math.floor((amount - position - 1) / 100);
                } else {
                    passesZero = 0;
                }

                let val = (position - amount) % 100;
                if (val < 0) val += 100;
                position = val;

                // Decreasing position means rotating dial CW (positive)
                currentRotation += amount * 3.6;
            }

            part2Count += passesZero;
            updateResult();

            // Animate
            const duration = fastMode ? 100 : Math.max(100, 510 - speedSlider.value); // Single smooth move
            dial.style.transition = `transform ${duration}ms linear`; // Linear for constant speed feel
            updateDial();

            if (passesZero > 0 && !fastMode) {
                dialContainer.classList.add('flash');
                setTimeout(() => dialContainer.classList.remove('flash'), 300);
            }

            await new Promise(r => setTimeout(r, duration));

            // Check Part 1 (End position)
            if (position === 0) {
                part1Count++;
                updateResult();
            }
        }

        async function runAll() {
            if (isExecuting) return;  // Prevent starting while step is executing

            if (currentIndex >= instructions.length) {
                // stopAnimation();
                const unlockMsg = currentPart === 1 ? `HQ LOCATED: ${part1Count}` : `BASEMENT FOUND: ${part2Count}`;
                updateStatus(unlockMsg, 'complete');
                runBtn.textContent = "RESTART";
                runBtn.onclick = reset;
                return;
            }

            if (isRunning && !isPaused) {
                // Pause
                isPaused = true;
                runBtn.textContent = '‚ñ∂ Resume';
                stepBtn.disabled = false;
                updateStatus('SEQUENCE PAUSED', 'paused');
                return;
            }

            if (isPaused) {
                // Resume
                isPaused = false;
                runBtn.textContent = '‚è∏ Pause';
                stepBtn.disabled = true;
                updateStatus('ROTATING...', 'running');
                return;
            }
            // else { // This empty else was redundant and causing a syntax error with the following else
            // } else { // This was the start of the duplicate logic
            // startAnimation();
            const runMsg = currentPart === 1 ? "TRIANGULATING..." : "FLOOR SCANNING...";
            updateStatus(runMsg, 'running');
            runBtn.textContent = "PAUSE";
            // } // Closing brace for the removed duplicate else

            // Start fresh
            if (currentIndex === 0) {
                parseInstructions();
                reset(); // Reset ensuring clean slate
            }

            isRunning = true;
            isPaused = false;
            runBtn.textContent = '‚è∏ Pause';
            stepBtn.disabled = true;
            updateStatus('CRACKING...', 'running');

            while (currentIndex < instructions.length) {
                if (!isRunning) break;

                const inst = instructions[currentIndex];
                await executeInstruction(inst);
                currentIndex++;

                // Check for pause AFTER instruction completes
                const shouldPauseAfter = stepOnce;
                stepOnce = false;

                if (shouldPauseAfter || isPaused) {
                    isPaused = true;
                    runBtn.textContent = '‚ñ∂ Resume';
                    stepBtn.disabled = false;
                    updateStatus(currentInput === exampleData ? "DEMO MODE" : "TIMELOCK ACTIVE", 'paused');

                    // Wait while paused (unless stepOnce signals to continue)
                    while (isPaused && isRunning && !stepOnce) {
                        await new Promise(r => setTimeout(r, 100));
                    }

                    if (stepOnce) {
                        // Continue but will pause after next instruction
                    }
                }

                fastMode = false;  // Reset fast mode after each instruction

                await new Promise(r => setTimeout(r, 100));
            }

            isRunning = false;
            isPaused = false;
            instructionEl.textContent = '‚úì';
            updateStatus('ACCESS GRANTED', 'complete');
            runBtn.textContent = '‚ñ∂ Run';
            stepBtn.disabled = false;
        }

        async function step() {
            // If animation is running, speed it up and prepare to pause after
            if (isRunning && !isPaused) {
                fastMode = true;
                isPaused = true;  // Will pause after current instruction completes
                return;
            }

            // If we're in a paused run, run one instruction fast
            if (isRunning && isPaused) {
                fastMode = true;
                stepOnce = true;
                return;
            }

            // Standalone step (not during run)
            if (isExecuting) return;
            if (currentIndex === 0) parseInstructions();
            if (currentIndex >= instructions.length) {
                instructionEl.textContent = '‚úì';
                return;
            }
            isExecuting = true;
            fastMode = true;  // Always use fast animation for step
            stepBtn.disabled = true;
            runBtn.disabled = true;

            await executeInstruction(instructions[currentIndex]);
            currentIndex++;

            isExecuting = false;
            fastMode = false;
            stepBtn.disabled = false;
            runBtn.disabled = false;

            if (currentIndex >= instructions.length) {
                instructionEl.textContent = '‚úì';
            }
        }

        createDialNumbers();
        // Initial parse
        parseInstructions();
        updateDial();

        runBtn.addEventListener('click', runAll);
        stepBtn.addEventListener('click', step);
        resetBtn.addEventListener('click', reset);
    </script>
</body>

</html>