<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advent of Code - Day 01 - Secret Entrance</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <h1>üîê SECRET VAULT CRACKER üîê</h1>
    <p class="subtitle">Day 1 - HQ Coordinate Triangulation System</p>

    <div class="container">
        <div class="safe-body">
            <div class="dial-container" id="dialContainer">
                <div class="dial-outer">
                    <div class="indicator"></div>
                </div>
                <div class="dial" id="dial">
                    <div class="dial-face" id="dialFace"></div>
                </div>
                <div class="center-hub"></div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Instruction</div>
                <div class="instruction" id="instruction">-</div>
            </div>
            <div class="stat-box">

                <div class="stat-label">Position</div>
                <div class="stat-value" id="position">50</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Part 1</div>
                <div class="stat-value zero-count" id="part1">0</div>
            </div>

            <div class="stat-box">
                <div class="stat-label">Part 2</div>
                <div class="stat-value zero-count" id="part2">0</div>
            </div>
        </div>

        <div class="controls">
            <button id="runBtn">‚ñ∂ Run</button>
            <button id="stepBtn">‚è≠ Step</button>
            <button id="resetBtn">üîÑ Reset</button>
            <button id="inputBtn">‚å® Input <span id="inputBadge" class="input-badge">EX</span></button>
            <div class="speed-control">
                <label>Speed:</label>
                <input type="range" id="speed" min="10" max="500" value="200">
            </div>
        </div>
    </div>

    <!-- Input Modal -->
    <div class="modal-overlay" id="inputModal">
        <div class="modal">
            <div class="modal-header">
                BASE PARAMETERS
                <button class="btn-modal" id="closeModalBtn" style="padding: 4px 8px; font-size: 1rem;">√ó</button>
            </div>
            <div class="modal-body">
                <label>Enter standard-issue coordinate instructions:</label>
                <textarea id="modalInputArea" placeholder="L5, R1, R3, L9..."></textarea>
            </div>
            <div class="modal-footer">
                <button class="btn-modal" id="useExampleBtn">Use Example</button>
                <button class="btn-modal btn-primary" id="useCustomBtn">Load Data</button>
            </div>
        </div>
    </div>

    <script>
        const dial = document.getElementById('dial');
        const dialFace = document.getElementById('dialFace');
        const dialContainer = document.getElementById('dialContainer');
        const positionEl = document.getElementById('position');
        const part1El = document.getElementById('part1');
        const part2El = document.getElementById('part2');
        const instructionEl = document.getElementById('instruction');
        const runBtn = document.getElementById('runBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedSlider = document.getElementById('speed');
        const inputBtn = document.getElementById('inputBtn');
        const inputBadge = document.getElementById('inputBadge');

        // Modal Elements
        const inputModal = document.getElementById('inputModal');
        const modalInputArea = document.getElementById('modalInputArea');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const useExampleBtn = document.getElementById('useExampleBtn');
        const useCustomBtn = document.getElementById('useCustomBtn');

        const exampleData = `L68
L30
R48
L5
R60
L55
L1
L99
R14
L82`;

        const STORAGE_KEY = 'day1_custom_input';
        let currentInput = localStorage.getItem(STORAGE_KEY) || exampleData;
        let isCustom = !!localStorage.getItem(STORAGE_KEY);

        // Update Badge
        function updateBadge() {
            if (isCustom) {
                inputBadge.textContent = "CUSTOM";
                inputBadge.classList.add('custom');
            } else {
                inputBadge.textContent = "EX";
                inputBadge.classList.remove('custom');
            }
        }
        updateBadge();



        let position = 50;
        let part1Count = 0;
        let part2Count = 0;
        let instructions = [];
        let currentIndex = 0;
        let isRunning = false;
        let isPaused = false;
        let isExecuting = false;
        let stepOnce = false;
        let fastMode = false;  // Flag for fast 0.1s animation

        function createDialNumbers() {
            const faceCenter = 115;

            for (let i = 0; i < 100; i++) {
                // Dial rotates, so position numbers relative to dial, not screen
                const angle = (i * 3.6 - 90) * Math.PI / 180;

                // Add tick marks
                const tick = document.createElement('div');
                tick.className = 'dial-tick' + (i % 5 === 0 ? ' major' : '');
                tick.style.left = `${faceCenter}px`;
                tick.style.top = '10px';
                tick.style.transform = `rotate(${i * 3.6}deg)`;
                dialFace.appendChild(tick);

                // Add numbers every 5
                if (i % 5 === 0) {
                    const radius = 85;
                    const x = faceCenter + radius * Math.cos(angle);
                    const y = faceCenter + radius * Math.sin(angle);
                    const rotationAngle = i * 3.6; // Rotate number to point outward

                    const numEl = document.createElement('div');
                    numEl.className = 'dial-number' + (i === 0 ? ' zero' : '');
                    numEl.textContent = i;
                    numEl.style.left = `${x}px`;
                    numEl.style.top = `${y}px`;
                    numEl.style.transform = `translate(-50%, -50%) rotate(${rotationAngle}deg)`;
                    numEl.id = `num-${i}`;
                    dialFace.appendChild(numEl);
                }
            }
        }

        function updateDial() {
            // Rotate the dial so current position aligns with top indicator
            // Use currentRotation to support smooth multi-turn animations
            dial.style.transform = `rotate(${currentRotation}deg)`;
            positionEl.textContent = position;

            // Update highlighting
            document.querySelectorAll('.dial-number').forEach(el => {
                el.classList.remove('current');
            });
            const nearestFive = Math.round(position / 5) * 5 % 100;
            const numEl = document.getElementById(`num-${nearestFive}`);
            if (numEl && Math.abs(position - nearestFive) <= 2) {
                numEl.classList.add('current');
            }
        }

        function parseInstructions() {
            const text = currentInput.trim();
            instructions = text.split(/\r?\n/).filter(line => line.trim()).map(line => line.trim().replace(/,$/, ''));
            // Handle comma separated if user pastes single line
            if (instructions.length === 1 && instructions[0].includes(',')) {
                instructions = instructions[0].split(',').map(s => s.trim());
            }
            currentIndex = 0;
        }

        function reset() {
            position = 50;
            part1Count = 0;
            part2Count = 0;
            currentIndex = 0;
            isRunning = false;
            updateDial();
            part1El.textContent = '0';
            part2El.textContent = '0';
            instructionEl.textContent = '-';
            runBtn.disabled = false;
            stepBtn.disabled = false;
        }

        let currentRotation = -180; // Starting at 50 (-180deg) matches initial position

        async function executeInstruction(inst) {
            const direction = inst[0];
            const amount = parseInt(inst.substring(1));
            instructionEl.textContent = inst;

            // Math Optimization (matches solution.ts)
            // Instead of simulating ticks, calculate valid zero-crossings directly

            let passesZero = 0;
            // Note: In solution.ts, logic handles 0-99 range naturally.
            // Current position 0-99.

            if (direction === 'R') {
                passesZero = Math.floor((position + amount) / 100);
                position = (position + amount) % 100;
                // Accumulate rotation: Increasing position means rotating dial CCW (negative)
                currentRotation -= amount * 3.6;
            } else if (direction === 'L') {
                // ... (simplified logic)
                if (position < amount) {
                    passesZero = 1 + Math.floor((amount - position - 1) / 100);
                } else {
                    passesZero = 0;
                }

                let val = (position - amount) % 100;
                if (val < 0) val += 100;
                position = val;

                // Decreasing position means rotating dial CW (positive)
                currentRotation += amount * 3.6;
            }

            part2Count += passesZero;
            part2El.textContent = part2Count;

            // Animate
            const duration = fastMode ? 100 : Math.max(100, 510 - speedSlider.value); // Single smooth move
            dial.style.transition = `transform ${duration}ms linear`; // Linear for constant speed feel
            updateDial();

            if (passesZero > 0 && !fastMode) {
                dialContainer.classList.add('flash');
                setTimeout(() => dialContainer.classList.remove('flash'), 300);
            }

            await new Promise(r => setTimeout(r, duration));

            // Check Part 1 (End position)
            if (position === 0) {
                part1Count++;
                part1El.textContent = part1Count;
            }
        }

        async function runAll() {
            if (isExecuting) return;  // Prevent starting while step is executing

            if (isRunning && !isPaused) {
                // Pause
                isPaused = true;
                runBtn.textContent = '‚ñ∂ Resume';
                stepBtn.disabled = false;  // Enable step while paused
                return;
            }

            if (isPaused) {
                // Resume
                isPaused = false;
                runBtn.textContent = '‚è∏ Pause';
                stepBtn.disabled = true;  // Disable step while running
                return;
            }

            // Start fresh
            parseInstructions();
            reset();
            isRunning = true;
            isPaused = false;
            runBtn.textContent = '‚è∏ Pause';
            stepBtn.disabled = true;

            while (currentIndex < instructions.length) {
                if (!isRunning) break;

                const inst = instructions[currentIndex];
                await executeInstruction(inst);
                currentIndex++;

                // Check for pause AFTER instruction completes
                const shouldPauseAfter = stepOnce;
                stepOnce = false;

                if (shouldPauseAfter || isPaused) {
                    isPaused = true;
                    runBtn.textContent = '‚ñ∂ Resume';
                    stepBtn.disabled = false;

                    // Wait while paused (unless stepOnce signals to continue)
                    while (isPaused && isRunning && !stepOnce) {
                        await new Promise(r => setTimeout(r, 100));
                    }

                    if (stepOnce) {
                        // Continue but will pause after next instruction
                    }
                }

                fastMode = false;  // Reset fast mode after each instruction

                await new Promise(r => setTimeout(r, 100));
            }

            isRunning = false;
            isPaused = false;
            instructionEl.textContent = '‚úì';
            runBtn.textContent = '‚ñ∂ Run';
            stepBtn.disabled = false;
        }

        async function step() {
            // If animation is running, speed it up and prepare to pause after
            if (isRunning && !isPaused) {
                fastMode = true;
                isPaused = true;  // Will pause after current instruction completes
                return;
            }

            // If we're in a paused run, run one instruction fast
            if (isRunning && isPaused) {
                fastMode = true;
                stepOnce = true;
                return;
            }

            // Standalone step (not during run)
            if (isExecuting) return;
            if (currentIndex === 0) parseInstructions();
            if (currentIndex >= instructions.length) {
                instructionEl.textContent = '‚úì';
                return;
            }
            isExecuting = true;
            fastMode = true;  // Always use fast animation for step
            stepBtn.disabled = true;
            runBtn.disabled = true;

            await executeInstruction(instructions[currentIndex]);
            currentIndex++;

            isExecuting = false;
            fastMode = false;
            stepBtn.disabled = false;
            runBtn.disabled = false;

            if (currentIndex >= instructions.length) {
                instructionEl.textContent = '‚úì';
            }
        }

        createDialNumbers();
        updateDial();

        // Modal Logic
        function openModal() {
            modalInputArea.value = isCustom ? currentInput : '';
            inputModal.classList.add('show');
        }

        function closeModal() {
            inputModal.classList.remove('show');
        }

        function setCustomInput() {
            const val = modalInputArea.value.trim();
            if (val) {
                currentInput = val;
                isCustom = true;
                localStorage.setItem(STORAGE_KEY, val);
                updateBadge();
                reset(); // Apply new input
                closeModal();
            }
        }

        function setExampleInput() {
            currentInput = exampleData;
            isCustom = false;
            localStorage.removeItem(STORAGE_KEY);
            updateBadge();
            reset(); // Apply new input
            closeModal();
        }

        inputBtn.addEventListener('click', openModal);
        closeModalBtn.addEventListener('click', closeModal);
        useCustomBtn.addEventListener('click', setCustomInput);
        useExampleBtn.addEventListener('click', setExampleInput);
        inputModal.addEventListener('click', (e) => {
            if (e.target === inputModal) closeModal();
        });

        runBtn.addEventListener('click', runAll);
        stepBtn.addEventListener('click', step);
        resetBtn.addEventListener('click', reset);
    </script>
</body>

</html>