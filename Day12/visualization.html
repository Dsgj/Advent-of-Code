<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advent of Code - Day 12 - Christmas Tree Farm</title>
    <link rel="stylesheet" href="../common.css">
    <link rel="stylesheet" href="style.css">

</head>

<body>
    <header class="page-header">
        <div class="header-row">
            <a href="../index.html" class="home-link">‚Üê Calendar</a>
            <div class="header-center">
                <h1>Christmas Tree Farm</h1>
            </div>
            <div class="header-right">
                <div class="status-panel-header">
                    <div class="status-light" id="statusLight"></div>
                    <span class="status-text text-glow" id="statusText">AWAITING ORDER</span>
                </div>
            </div>
        </div>
        <div class="header-controls">
            <button id="part1Btn" class="active">Part 1</button>
            <button id="part2Btn" disabled
                style="opacity: 0.5; cursor: not-allowed; text-decoration: line-through;">Part 2</button>
            <button id="inputBtn">‚å® Input</button>
        </div>
    </header>

    <main>
        <!-- Banner Removed per user request -->

        <!-- Top Section: Overview + Controls -->
        <!-- Main Content Area -->
        <div class="content-area">
            <div class="viz-panel">
                <div class="panel-title">üìä Region Overview</div>

                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                        <span class="progress-text" id="progress-text">0 / 0</span>
                    </div>
                </div>

                <p style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                    Click any cell to see region details. <span style="color: #2ecc71;">‚ñ† fits</span> <span
                        style="color: #e74c3c;">‚ñ† doesn't fit</span>
                </p>

                <div class="region-overview" id="region-overview"></div>
            </div>

            <div class="stats-sidebar">
                <div class="stats-panel">
                    <h2>‚öô Controls</h2>
                    <div class="controls" style="margin-bottom: 1rem; display: flex; flex-direction: column; gap: 8px;">
                        <button id="btn-solve-all" class="btn btn-primary" style="width: 100%;">‚ñ∂ Solve All</button>
                        <button id="btn-stop" class="btn btn-secondary" disabled style="width: 100%;">‚èπ Stop</button>
                        <button id="btn-reset" class="btn btn-secondary" style="width: 100%;">‚Ü∫ Reset</button>
                    </div>

                    <h2>üéÅ Shapes</h2>
                    <div class="shapes-mini" id="shapes-display"></div>

                    <h2 style="margin-top: 1rem;">üìà Statistics</h2>
                    <div class="stats-list">
                        <div class="stat-item success">
                            <span class="label">Can Fit ‚úì</span>
                            <span id="stat-success" class="value">0</span>
                        </div>
                        <div class="stat-item failure">
                            <span class="label">Cannot Fit ‚úó</span>
                            <span id="stat-failure" class="value">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="label">Processed</span>
                            <span id="stat-processed" class="value">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script src="../common.js"></script>
        <!-- Detail Popup -->
        <div class="detail-popup-overlay" id="detail-popup-overlay">
            <div class="detail-popup" id="detail-popup">
                <button class="close-btn" id="close-popup">√ó</button>
                <h3>Region <span id="detail-index">0</span></h3>
                <div class="stats-list">
                    <div class="stat-item">
                        <span class="label">Size</span>
                        <span id="detail-size" class="value">0x0</span>
                    </div>
                    <div class="stat-item">
                        <span class="label">Pieces</span>
                        <span id="detail-pieces" class="value">0</span>
                    </div>
                    <div id="detail-status" class="stat-item">
                        <span class="label">Status</span>
                        <span class="value">Pending</span>
                    </div>
                </div>
                <div class="pieces-needed" id="detail-pieces-list"></div>
                <div class="detail-grid-container">
                    <div class="detail-grid" id="detail-grid"></div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Example input
        const EXAMPLE_INPUT = `0:
###
.#.
###

1:
..#
.##
###

2:
###
###
..#

3:
.##
###
#.#

4:
##.
.##
..#

5:
#.#
#.#
###

4x4: 0 0 0 0 2 0
12x5: 1 0 1 0 2 2
12x5: 1 0 1 0 3 2`;

        // State
        let shapes = [];
        let allVariants = [];
        let regions = [];
        let results = []; // 'pending' | 'success' | 'failure'
        let isRunning = false;
        let currentIndex = 0;
        let successCount = 0;
        let failureCount = 0;
        let selectedRegion = -1;
        let abortFlag = false;

        const statusTextEl = document.getElementById('statusText');
        const statusLightEl = document.getElementById('statusLight');

        function updateStatus(text, state) {
            statusTextEl.textContent = text;
            statusLightEl.className = 'status-light ' + state;
        }

        // Parse functions
        function parseShape(block) {
            const lines = block.trim().split(/\r?\n/).slice(1);
            const coords = [];
            for (let row = 0; row < lines.length; row++) {
                for (let col = 0; col < lines[row].length; col++) {
                    if (lines[row][col] === '#') {
                        coords.push([row, col]);
                    }
                }
            }
            return coords;
        }

        function normalize(shape) {
            if (shape.length === 0) return shape;
            const minRow = Math.min(...shape.map(c => c[0]));
            const minCol = Math.min(...shape.map(c => c[1]));
            return shape.map(([r, c]) => [r - minRow, c - minCol])
                .sort((a, b) => a[0] - b[0] || a[1] - b[1]);
        }

        function rotate90(shape) {
            return normalize(shape.map(([r, c]) => [c, -r]));
        }

        function flipH(shape) {
            return normalize(shape.map(([r, c]) => [r, -c]));
        }

        function generateVariants(shape) {
            const variants = [];
            const seen = new Set();
            let current = normalize(shape);
            for (let flip = 0; flip < 2; flip++) {
                for (let rot = 0; rot < 4; rot++) {
                    const key = JSON.stringify(current);
                    if (!seen.has(key)) {
                        seen.add(key);
                        variants.push(current);
                    }
                    current = rotate90(current);
                }
                current = flipH(current);
            }
            return variants;
        }

        function parseInput(input) {
            const blocks = input.trim().split(/\r?\n\r?\n/);
            shapes = [];
            regions = [];

            for (const block of blocks) {
                const trimmed = block.trim();
                const lines = trimmed.split(/\r?\n/);
                let hasShape = false;

                for (const line of lines) {
                    const lineTrimmed = line.trim();
                    const match = lineTrimmed.match(/^(\d+)x(\d+):\s*(.*)$/);
                    if (match) {
                        const width = parseInt(match[1]);
                        const height = parseInt(match[2]);
                        const counts = match[3].split(/\s+/).map(n => parseInt(n));
                        regions.push({ width, height, counts });
                    } else if (lineTrimmed.match(/^\d+:$/)) {
                        hasShape = true;
                    }
                }

                if (hasShape && lines[0].match(/^\d+:$/)) {
                    shapes.push(parseShape(trimmed));
                }
            }

            allVariants = shapes.map(s => generateVariants(s));
            results = regions.map(() => 'pending');
            successCount = 0;
            failureCount = 0;
            currentIndex = 0;
            selectedRegion = -1;
        }

        // Solver (synchronous for speed)
        function canPlace(variant, startRow, startCol, grid, width, height) {
            for (const [dr, dc] of variant) {
                const r = startRow + dr;
                const c = startCol + dc;
                if (r < 0 || r >= height || c < 0 || c >= width) return false;
                if (grid[r][c]) return false;
            }
            return true;
        }

        function placeShape(variant, startRow, startCol, grid) {
            for (const [dr, dc] of variant) {
                grid[startRow + dr][startCol + dc] = true;
            }
        }

        function removeShape(variant, startRow, startCol, grid) {
            for (const [dr, dc] of variant) {
                grid[startRow + dr][startCol + dc] = false;
            }
        }

        function solve(pieces, pieceIndex, grid, width, height) {
            if (pieceIndex >= pieces.length) return true;

            const shapeIdx = pieces[pieceIndex];
            const variants = allVariants[shapeIdx];

            for (const variant of variants) {
                for (let row = 0; row < height; row++) {
                    for (let col = 0; col < width; col++) {
                        if (canPlace(variant, row, col, grid, width, height)) {
                            placeShape(variant, row, col, grid);
                            if (solve(pieces, pieceIndex + 1, grid, width, height)) {
                                return true;
                            }
                            removeShape(variant, row, col, grid);
                        }
                    }
                }
            }
            return false;
        }

        // Solve and return the solution grid with piece labels
        function solveWithSolution(region) {
            const pieces = [];
            for (let i = 0; i < region.counts.length; i++) {
                for (let j = 0; j < region.counts[i]; j++) {
                    pieces.push(i);
                }
            }

            if (pieces.length === 0) return { success: true, grid: null };

            const totalCells = pieces.reduce((sum, idx) => sum + shapes[idx].length, 0);
            if (totalCells > region.width * region.height) return { success: false, grid: null };

            // Grid stores piece index (0-based) or -1 for empty
            const grid = Array.from({ length: region.height }, () => Array(region.width).fill(-1));
            pieces.sort((a, b) => shapes[b].length - shapes[a].length);

            function solveRecursive(pieceIndex) {
                if (pieceIndex >= pieces.length) return true;

                const shapeIdx = pieces[pieceIndex];
                const variants = allVariants[shapeIdx];

                for (const variant of variants) {
                    for (let row = 0; row < region.height; row++) {
                        for (let col = 0; col < region.width; col++) {
                            let canFit = true;
                            for (const [dr, dc] of variant) {
                                const r = row + dr;
                                const c = col + dc;
                                if (r < 0 || r >= region.height || c < 0 || c >= region.width || grid[r][c] !== -1) {
                                    canFit = false;
                                    break;
                                }
                            }
                            if (canFit) {
                                // Place with piece index
                                for (const [dr, dc] of variant) {
                                    grid[row + dr][col + dc] = pieceIndex;
                                }
                                if (solveRecursive(pieceIndex + 1)) {
                                    return true;
                                }
                                // Remove
                                for (const [dr, dc] of variant) {
                                    grid[row + dr][col + dc] = -1;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            const success = solveRecursive(0);
            return { success, grid: success ? grid : null };
        }

        function solveRegion(region) {
            const pieces = [];
            for (let i = 0; i < region.counts.length; i++) {
                for (let j = 0; j < region.counts[i]; j++) {
                    pieces.push(i);
                }
            }

            if (pieces.length === 0) return true;

            const totalCells = pieces.reduce((sum, idx) => sum + shapes[idx].length, 0);
            if (totalCells > region.width * region.height) return false;

            const grid = Array.from({ length: region.height }, () => Array(region.width).fill(false));
            pieces.sort((a, b) => shapes[b].length - shapes[a].length);

            return solve(pieces, 0, grid, region.width, region.height);
        }

        // UI Rendering
        function renderShapes() {
            const container = document.getElementById('shapes-display');
            container.innerHTML = '';

            shapes.forEach((shape, idx) => {
                const maxRow = Math.max(...shape.map(c => c[0])) + 1;
                const maxCol = Math.max(...shape.map(c => c[1])) + 1;

                const mini = document.createElement('div');
                mini.className = 'shape-mini';
                mini.style.gridTemplateColumns = `repeat(${maxCol}, 6px)`;
                mini.title = `Shape ${idx} (${shape.length} cells)`;

                for (let r = 0; r < maxRow; r++) {
                    for (let c = 0; c < maxCol; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'scell ' + (shape.some(([sr, sc]) => sr === r && sc === c) ? 'on' : 'off');
                        mini.appendChild(cell);
                    }
                }
                container.appendChild(mini);
            });
        }

        function renderOverview() {
            const container = document.getElementById('region-overview');
            container.innerHTML = '';

            const count = regions.length;
            if (count === 0) return;

            // Get available space
            const maxH = 500; // Match CSS max-height
            const containerW = container.clientWidth || container.parentElement.clientWidth || 800;
            const gap = 4;

            // Goal: Find cols such that:
            // 1. count % cols === 0 (Rectangular grid)
            // 2. Height <= maxH (No scroll)
            // Height approx = rows * cell_size
            // cell_size = (W - (cols-1)*gap) / cols
            // rows = count / cols

            // Derive required cols:
            // rows * S <= maxH
            // (count/cols) * (W/cols) <= maxH  (Approximating S ~= W/cols)
            // count * W / cols^2 <= maxH
            // cols^2 >= count * W / maxH
            // cols >= sqrt(count * W / maxH)

            const minColsByHeight = Math.ceil(Math.sqrt(count * containerW / maxH));

            // Find factors of count
            let factors = [];
            for (let i = 1; i <= Math.sqrt(count); i++) {
                if (count % i === 0) {
                    factors.push(i);
                    if (i !== count / i) factors.push(count / i);
                }
            }
            factors.sort((a, b) => a - b);

            // Find smallest factor >= minColsByHeight
            let bestCols = factors.find(f => f >= minColsByHeight);

            // Fallback: If no factor fits (e.g. prime or very large minCols compared to factors), 
            // or if bestCols results in tiny cells (< 10px), maybe we accept scrolling or imperfect grid?
            // User said "We want to see ALL". "No scroll".
            // So we MUST satisfy Height <= maxH constraint.
            // If bestCols doesn't exist (e.g. minCols > max_factor = count), then we have to use 'count' columns (1 row) 
            // if we must match factor. But 1 row of 1000 items is absurd.

            if (!bestCols) {
                // Prime number or awkward dimensions?
                // Just use the minCols calculated to fit height, even if it leaves ragged row.
                // Or try to fit perfectly by not using factors (CSS grid auto-fill logic essentially)
                // giving up on "equal items per row" strictness for the last row.
                // But user specifically asked for "equal per row".
                // "om det inte √§r ett primtal" -> implies if composite, we MUST do equal.
                // So if composite, bestCols SHOULD be found unless minCols is huge.
                // For N=1000, minCols ~ sqrt(1000*300/500) = sqrt(600) = 24.
                // Factors of 1000: ... 20, 25, 40 ...
                // 25 >= 24. So 25 cols. 40 rows. 
                // Cell size W/25. If W=300, S=12px. H=40*12=480 < 500. Perfect.

                // If we failed to find factor (e.g. prime), fallback to minCols to ensure fit.
                bestCols = minColsByHeight;
            }

            container.style.gridTemplateColumns = `repeat(${bestCols}, 1fr)`;

            regions.forEach((region, idx) => {
                const cell = document.createElement('div');
                cell.className = 'region-cell ' + results[idx];
                cell.title = `Region ${idx + 1}: ${region.width}x${region.height}`;
                cell.dataset.index = idx;
                if (idx === selectedRegion) cell.classList.add('selected');

                // Add click handler
                cell.onclick = (e) => selectRegion(idx, e);

                container.appendChild(cell);
            });

            document.getElementById('total-regions').textContent = regions.length;
        }

        function updateProgress() {
            const processed = successCount + failureCount;
            const percent = regions.length > 0 ? (processed / regions.length * 100) : 0;

            document.getElementById('progress-fill').style.width = percent + '%';
            document.getElementById('progress-text').textContent = `${processed} / ${regions.length}`;
            document.getElementById('stat-success').textContent = successCount;
            document.getElementById('stat-failure').textContent = failureCount;
            document.getElementById('stat-processed').textContent = processed;
        }

        function updateCell(idx, status) {
            results[idx] = status;
            const cell = document.querySelector(`.region-cell[data-index="${idx}"]`);
            if (cell) {
                cell.className = 'region-cell ' + status;
                if (idx === selectedRegion) cell.classList.add('selected');
            }
        }

        function selectRegion(idx, event) {
            const prev = document.querySelector('.region-cell.selected');
            if (prev) prev.classList.remove('selected');

            selectedRegion = idx;
            const cell = document.querySelector(`.region-cell[data-index="${idx}"]`);
            if (cell) cell.classList.add('selected');

            // Show popup with animation from clicked cell
            const overlay = document.getElementById('detail-popup-overlay');
            const popup = document.getElementById('detail-popup');

            // Calculate origin from clicked cell
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const originX = rect.left + rect.width / 2;
                const originY = rect.top + rect.height / 2;
                popup.style.setProperty('--origin-x', originX + 'px');
                popup.style.setProperty('--origin-y', originY + 'px');
            }

            // Force re-animation by toggling
            popup.style.animation = 'none';
            popup.offsetHeight; // Trigger reflow
            popup.style.animation = 'popupGrow 0.25s ease-out';

            overlay.classList.add('active');
            renderDetail(idx);
        }

        function closePopup() {
            document.getElementById('detail-popup-overlay').classList.remove('active');
            const prev = document.querySelector('.region-cell.selected');
            if (prev) prev.classList.remove('selected');
            selectedRegion = -1;
        }

        function renderDetail(idx) {
            const region = regions[idx];
            document.getElementById('detail-index').textContent = idx + 1;
            document.getElementById('detail-size').textContent = `${region.width}x${region.height}`;

            const pieces = [];
            for (let i = 0; i < region.counts.length; i++) {
                for (let j = 0; j < region.counts[i]; j++) {
                    pieces.push(i);
                }
            }

            document.getElementById('detail-pieces').textContent = pieces.length;

            const statusEl = document.getElementById('detail-status');
            const status = results[idx];
            statusEl.className = 'stat-item ' + (status === 'success' ? 'success' : status === 'failure' ? 'failure' : '');
            statusEl.querySelector('.value').textContent = status === 'pending' ? 'Pending' : status === 'success' ? '‚úì Fits!' : '‚úó No fit';

            // Pieces list
            const piecesList = document.getElementById('detail-pieces-list');
            piecesList.innerHTML = '';
            const countMap = {};
            pieces.forEach(p => countMap[p] = (countMap[p] || 0) + 1);
            Object.keys(countMap).forEach(p => {
                const tag = document.createElement('span');
                tag.className = 'piece-tag';
                tag.innerHTML = `Shape ${p}: <span>${countMap[p]}</span>`;
                piecesList.appendChild(tag);
            });

            // Grid preview - show solution if available
            const gridContainer = document.getElementById('detail-grid');
            const cellSize = Math.max(6, Math.min(16, Math.floor(300 / Math.max(region.width, region.height))));

            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${region.width}, ${cellSize}px)`;

            // Colors for pieces
            const pieceColors = [
                '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#e91e63', '#00bcd4', '#ff5722', '#8bc34a',
                '#673ab7', '#ffeb3b', '#795548', '#607d8b', '#ff9800'
            ];

            // Try to get solution
            let solutionGrid = null;
            if (status === 'success') {
                const result = solveWithSolution(region);
                solutionGrid = result.grid;
            }

            for (let r = 0; r < region.height; r++) {
                for (let c = 0; c < region.width; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.width = cellSize + 'px';
                    cell.style.height = cellSize + 'px';

                    if (solutionGrid && solutionGrid[r][c] !== -1) {
                        const pieceIdx = solutionGrid[r][c];
                        cell.style.background = pieceColors[pieceIdx % pieceColors.length];
                        cell.style.boxShadow = `inset 0 0 2px rgba(255,255,255,0.5)`;
                    }

                    gridContainer.appendChild(cell);
                }
            }
        }

        // Solve all (async with batching for responsiveness)
        async function solveAll() {
            isRunning = true;
            abortFlag = false;
            document.getElementById('btn-solve-all').disabled = true;
            document.getElementById('btn-stop').disabled = false;
            // Part 2 is disabled in Day 12 anyway, but good practice
            updateStatus("PROCESSING BATCH...", "running");

            const batchSize = 5;

            while (currentIndex < regions.length && !abortFlag) {
                // Process a batch
                for (let i = 0; i < batchSize && currentIndex < regions.length; i++) {
                    const idx = currentIndex;
                    updateCell(idx, 'processing');

                    // Use setTimeout to allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 0));

                    const success = solveRegion(regions[idx]);
                    if (success) {
                        successCount++;
                        updateCell(idx, 'success');
                    } else {
                        failureCount++;
                        updateCell(idx, 'failure');
                    }

                    currentIndex++;
                    updateProgress();
                }

                // Allow UI to breathe
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            isRunning = false;
            document.getElementById('btn-solve-all').disabled = false;
            document.getElementById('btn-stop').disabled = true;
            updateStatus("BATCH COMPLETE", "complete");
        }

        function resetVisualization() {
            isRunning = false;
            // grid = []; // Don't wipe grid reference, just clear logic? 
            // Actually regenerate grid from input
            // solve(currentInput); // This line seems to be from a different context, removing it.
            updateStatus("AWAITING ORDER", "ready");
        }

        function stopSolving() {
            abortFlag = true;
            updateStatus("HALTED", "paused");
        }

        // Event handlers
        document.getElementById('btn-solve-all').onclick = solveAll;
        document.getElementById('btn-stop').onclick = stopSolving;
        document.getElementById('btn-reset').onclick = () => {
            // Stop any running process
            stopSolving();
            isRunning = false;
            document.getElementById('btn-solve-all').disabled = false;
            document.getElementById('btn-stop').disabled = true;

            // Reset State
            results = regions.map(() => 'pending');
            successCount = 0;
            failureCount = 0;
            currentIndex = 0;
            selectedRegion = -1;

            // Reset UI
            renderOverview(); // Re-render grid to clear classes
            updateProgress();

            // Close any open popup
            closePopup();
        };

        // Popup close handlers (Region Details)
        document.getElementById('close-popup').onclick = closePopup;
        document.getElementById('detail-popup-overlay').onclick = (e) => {
            if (e.target === e.currentTarget) closePopup();
        };

        // --- Standard Input Modal Handlers ---
        Common.setupInputModal({
            placeholder: 'Paste your Christmas Tree Farm grid (e.g., RRRRIICCFF...)',
            storageKey: 'day12-input',
            exampleInput: EXAMPLE_INPUT,
            onLoad: (input) => {
                // Reset and Process
                parseInput(input);
                renderShapes();
                renderOverview();
                updateProgress();

                // Clean up any open detail views
                document.getElementById('detail-popup-overlay').style.display = 'none';
            }
        });

        // Part Buttons
        const p1Btn = document.getElementById('part1Btn');
        const p2Btn = document.getElementById('part2Btn');

        // Disable Part 2 explicitly via JS as well, just in case
        p2Btn.disabled = true;
        p2Btn.style.opacity = '0.5';
        p2Btn.style.cursor = 'not-allowed';

        p1Btn.addEventListener('click', () => {
            // Already active, do nothing or reset
        });


        // Init
        function init() {
            const saved = localStorage.getItem('day12-input');
            const input = saved || EXAMPLE_INPUT;

            parseInput(input);
            renderShapes();
            renderOverview();
            updateProgress();
        }

        init();
    </script>
</body>

</html>