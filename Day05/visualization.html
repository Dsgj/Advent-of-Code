<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advent of Code - Day 05 - Cafeteria</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <h1>CAFETERIA INVENTORY SYSTEM</h1>
    <p class="subtitle">Validating Ingredients & Managing Spoilage</p>

    <div class="container">
        <!-- Control Panel -->
        <div class="panel">
            <div class="panel-header">SYSTEM CONTROLS</div>
            <div class="controls">
                <button id="part1Btn" class="active-mode">MODE: ITEM CHECK (PT 1)</button>
                <button id="part2Btn">MODE: RANGE MERGE (PT 2)</button>
            </div>
            <div class="controls">
                <button id="runBtn">▶ RUN PROCESS</button>
                <button id="stepBtn">⏯ STEP</button>
                <button id="resetBtn">↺ RESET</button>
                <button id="inputBtn">INPUT DATA <span id="inputBadge" class="input-badge">EX</span></button>
                <div class="speed-control">
                    <label>SPEED</label>
                    <input type="range" id="speedSlider" min="1" max="100" value="50">
                </div>
            </div>
        </div>

        <!-- Part 1 Display -->
        <div id="part1Panel" class="panel">
            <div class="panel-header">INGREDIENT VALIDATION (PART 1)</div>
            <p style="color:var(--dim-text); margin-bottom:10px;">Verify individual IDs against known fresh ranges.</p>
            <div class="grid-container" id="itemGrid">
                <!-- Items injected here -->
            </div>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Processed</div>
                    <div class="stat-value" id="p1Processed">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Fresh</div>
                    <div class="stat-value" style="color:var(--fresh-green)" id="p1Fresh">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Spoiled</div>
                    <div class="stat-value" style="color:var(--spoiled-red)" id="p1Spoiled">0</div>
                </div>
            </div>
        </div>

        <!-- Part 2 Display -->
        <div id="part2Panel" class="panel" style="display:none;">
            <div class="panel-header">RANGE OPTIMIZATION (PART 2)</div>
            <p style="color:var(--dim-text); margin-bottom:10px;">Sort and merge overlapping fresh ranges.</p>
            <div class="p2-split-container">
                <div class="list-col">
                    <div class="col-header">Sorted Source</div>
                    <div id="sourceList" class="scrollable-list"></div>
                </div>
                <div class="list-col">
                    <div class="col-header">Merged Results</div>
                    <div id="mergedList" class="scrollable-list"></div>
                </div>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Merged Ranges</div>
                    <div class="stat-value" id="p2MergedCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Fresh IDs</div>
                    <div class="stat-value" style="color:var(--fresh-green)" id="p2TotalFresh">0</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Input Modal -->
    <div class="modal-overlay" id="inputModal">
        <div class="modal">
            <h2>INPUT DATA INPUT</h2>
            <textarea id="modalInputArea" placeholder="Paste your puzzle input here..."></textarea>
            <div class="modal-btns">
                <button id="useExampleBtn">LOAD EXAMPLE</button>
                <button id="useCustomBtn" style="border-color:var(--warning-orange); color:var(--warning-orange)">LOAD
                    CUSTOM</button>
                <button id="closeModalBtn" style="border-color:var(--dim-text); color:var(--dim-text)">CANCEL</button>
            </div>
        </div>
    </div>

    <script>
        // --- DATA ---
        const EXAMPLE_INPUT = `3-5
10-14
16-20
12-18

1
5
8
11
17
32`;

        // --- STATE ---
        let rawInput = EXAMPLE_INPUT;
        let isCustom = false;
        let ranges = [];
        let items = [];
        let currentMode = 1; // 1 or 2
        let animationQueue = [];
        let isRunning = false;
        let timer = null;

        // --- DOM ---
        const part1Btn = document.getElementById('part1Btn');
        const part2Btn = document.getElementById('part2Btn');
        const part1Panel = document.getElementById('part1Panel');
        const part2Panel = document.getElementById('part2Panel');
        const itemGrid = document.getElementById('itemGrid');
        const p1Processed = document.getElementById('p1Processed');
        const p1Fresh = document.getElementById('p1Fresh');
        const p1Spoiled = document.getElementById('p1Spoiled');

        const runBtn = document.getElementById('runBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const inputBtn = document.getElementById('inputBtn');
        const speedSlider = document.getElementById('speedSlider');

        const p2MergedCount = document.getElementById('p2MergedCount');
        const p2TotalFresh = document.getElementById('p2TotalFresh');

        const sourceList = document.getElementById('sourceList');
        const mergedList = document.getElementById('mergedList');

        const inputModal = document.getElementById('inputModal');
        const modalInputArea = document.getElementById('modalInputArea');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const useExampleBtn = document.getElementById('useExampleBtn');
        const useCustomBtn = document.getElementById('useCustomBtn');
        const inputBadge = document.getElementById('inputBadge');

        // --- INIT ---
        function init() {
            const stored = localStorage.getItem('day5_input');
            if (stored) {
                rawInput = stored;
                isCustom = true;
                inputBadge.textContent = 'CUSTOM';
                inputBadge.classList.add('custom');
            }
            parseAndReset();
        }

        function parseAndReset() {
            stopAnimation();
            const normalizedInput = rawInput.replace(/\r/g, '');
            const lines = normalizedInput.split('\n');

            // Find first empty line
            const sepIdx = lines.findIndex(l => l.trim() === '');

            let rangeLines = [];
            let itemLines = [];

            if (sepIdx === -1) {
                // If no empty line found, try to guess or just warn
                console.warn("No empty line separator found. Assuming all lines are ranges if they contain '-'.");
                rangeLines = lines.filter(l => l.includes('-'));
                itemLines = lines.filter(l => !l.includes('-') && l.trim() !== '');
            } else {
                rangeLines = lines.slice(0, sepIdx);
                itemLines = lines.slice(sepIdx + 1);
            }

            // Parse Ranges
            ranges = rangeLines.map(l => {
                const line = l.trim();
                if (!line) return null;
                const [s, e] = line.split('-').map(Number);
                return { start: s, end: e, original: true };
            }).filter(r => r && !isNaN(r.start) && !isNaN(r.end));

            // Parse Items (joined and split by whitespace to handle multi-column or single-column)
            const itemText = itemLines.join(' ');
            items = itemText.split(/\s+/).map(Number).filter(n => !isNaN(n));

            resetUI();

            if (currentMode === 1) preparePart1();
            else preparePart2();
        }

        function resetUI() {
            itemGrid.innerHTML = '';
            if (sourceList) sourceList.innerHTML = '';
            if (mergedList) mergedList.innerHTML = '';
            p1Processed.textContent = '0';
            p1Fresh.textContent = '0';
            p1Spoiled.textContent = '0';
            p2MergedCount.textContent = '0';
            p2TotalFresh.textContent = '0';
            animationQueue = [];
        }

        // --- LOGIC: PART 1 ---
        function preparePart1() {
            // Visualize items
            items.forEach((id, idx) => {
                const el = document.createElement('div');
                el.className = 'item-box';
                el.textContent = id;
                el.id = `item-${idx}`;
                itemGrid.appendChild(el);

                // Build Animation Step
                animationQueue.push({
                    type: 'check_item',
                    id: id,
                    index: idx
                });
            });
        }

        function isFresh(id) {
            return ranges.some(r => id >= r.start && id <= r.end);
        }

        // --- LOGIC: PART 2 ---
        function preparePart2() {
            // Sort ranges first for display
            const sortedRanges = [...ranges].sort((a, b) => a.start - b.start);

            // Populated Source List
            sourceList.innerHTML = '';
            mergedList.innerHTML = '';

            sortedRanges.forEach((r, idx) => {
                const row = document.createElement('div');
                row.className = 'range-item';
                row.innerHTML = `<span class="range-vals">${r.start} - ${r.end}</span>`;
                row.id = `src-${idx}`;
                sourceList.appendChild(row);
            });

            // Generate Merge Steps
            let merged = [];
            if (sortedRanges.length > 0) {
                // Initialize first
                merged.push({ ...sortedRanges[0] });
                animationQueue.push({ type: 'init_merge', range: sortedRanges[0], idx: 0 });

                for (let i = 1; i < sortedRanges.length; i++) {
                    let current = sortedRanges[i];
                    let last = merged[merged.length - 1]; // This is a reference in logic, but UI will need check

                    // We passed "last" as copy to avoid mutation issues in visual queue logic if we were purely visual,
                    // but here we just need to know IF we merge or push.

                    const canMerge = current.start <= last.end + 1;

                    animationQueue.push({
                        type: 'check_merge',
                        idx: i,
                        canMerge: canMerge,
                        currentStart: current.start,
                        mergedEnd: last.end,
                        compareIdx: merged.length - 1 // Index of result we are checking against
                    });

                    if (canMerge) {
                        // Merge
                        last.end = Math.max(last.end, current.end);
                        animationQueue.push({
                            type: 'do_merge',
                            idx: i,
                            newEnd: last.end,
                            mergedIndex: merged.length - 1 // Index in result list
                        });
                    } else {
                        // New
                        merged.push({ ...current });
                        animationQueue.push({
                            type: 'push_new',
                            idx: i,
                            range: { ...current },
                            mergedIndex: merged.length - 1
                        });
                    }
                }

                animationQueue.push({ type: 'finish_merge', count: merged.length, total: merged.reduce((acc, r) => acc + (r.end - r.start + 1), 0) });
            }
        }

        // --- ANIMATION RUNNER ---
        // Helper to scroll item into view within its container
        function scrollToItem(container, item) {
            if (!container || !item) return;
            // Center the item
            const top = item.offsetTop;
            const height = item.clientHeight;
            const containerHeight = container.clientHeight;
            container.scrollTop = top - (containerHeight / 2) + (height / 2);
        }

        function runStep() {
            if (animationQueue.length === 0) {
                stopAnimation();
                return;
            }

            const step = animationQueue.shift();
            processStep(step);

            if (isRunning) {
                const delay = 1000 - (speedSlider.value * 9);
                timer = setTimeout(runStep, delay);
            }
        }

        function processStep(step) {
            if (currentMode === 1) {
                const el = document.getElementById(`item-${step.index}`);

                // Clear previous 'checking'
                const prev = document.querySelector('.item-box.checking');
                if (prev) prev.classList.remove('checking');

                if (step.type === 'check_item') {
                    el.classList.add('checking');
                    // el.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Removed for Part 1 or keep? Part 1 uses grid, keep standard but maybe use helper if grid is scrollable.
                    // Part 1 grid is .grid-container which scrolls.
                    scrollToItem(document.getElementById('itemGrid'), el);

                    const fresh = isFresh(step.id);
                    // Determine result immediately for visual snap (or could split into 2 steps)
                    setTimeout(() => {
                        el.classList.remove('checking');
                        if (fresh) {
                            el.classList.add('fresh');
                            p1Fresh.textContent = parseInt(p1Fresh.textContent) + 1;
                        } else {
                            el.classList.add('spoiled');
                            p1Spoiled.textContent = parseInt(p1Spoiled.textContent) + 1;
                        }
                        p1Processed.textContent = parseInt(p1Processed.textContent) + 1;
                    }, isRunning ? 200 : 0);
                }
            } else {
                // Part 2
                if (step.type === 'init_merge') {
                    // Mark source
                    const src = document.getElementById(`src-${step.idx}`);
                    if (src) src.classList.add('consumed');

                    // Create first result
                    const row = document.createElement('div');
                    row.className = 'range-item result';
                    row.innerHTML = `<span class="range-vals">${step.range.start} - ${step.range.end}</span>`;
                    row.id = `res-0`;
                    mergedList.appendChild(row);

                    p2MergedCount.textContent = 1;
                }
                else if (step.type === 'check_merge') {
                    const src = document.getElementById(`src-${step.idx}`);
                    if (src) {
                        src.classList.add('active');
                        scrollToItem(sourceList, src);
                    }
                    // Highlight the result we are comparing with
                    const res = document.getElementById(`res-${step.compareIdx}`);
                    if (res) res.classList.add('comparing');
                }
                else if (step.type === 'do_merge') {
                    const src = document.getElementById(`src-${step.idx}`);
                    if (src) {
                        src.classList.remove('active');
                        src.classList.add('consumed');
                    }

                    // Remove comparison highlight
                    const compareRes = document.querySelector('.range-item.comparing');
                    if (compareRes) compareRes.classList.remove('comparing');

                    // Update result
                    const res = document.getElementById(`res-${step.mergedIndex}`);
                    if (res) {
                        const span = res.querySelector('.range-vals');
                        // Get current start from text (hacky but simple)
                        const currentStart = span.textContent.split('-')[0].trim();
                        span.textContent = `${currentStart} - ${step.newEnd}`;

                        // Flash effect
                        res.classList.remove('flash-grow');
                        void res.offsetWidth; // trigger reflow
                        res.classList.add('flash-grow');
                    }
                }
                else if (step.type === 'push_new') {
                    const src = document.getElementById(`src-${step.idx}`);
                    if (src) {
                        src.classList.remove('active');
                        src.classList.add('consumed');
                    }

                    // Remove comparison highlight
                    const compareRes = document.querySelector('.range-item.comparing');
                    if (compareRes) compareRes.classList.remove('comparing');

                    // Create new result
                    const row = document.createElement('div');
                    row.className = 'range-item result flash-grow'; // Flash on create
                    row.innerHTML = `<span class="range-vals">${step.range.start} - ${step.range.end}</span>`;
                    row.id = `res-${step.mergedIndex}`;
                    mergedList.appendChild(row);

                    p2MergedCount.textContent = parseInt(p2MergedCount.textContent) + 1;

                    // Scroll result into view
                    scrollToItem(mergedList, row);
                }
                else if (step.type === 'finish_merge') {
                    p2TotalFresh.textContent = step.total;
                    // Optional: highlight total
                }
            }
        }

        function toggleRun() {
            if (isRunning) stopAnimation();
            else startAnimation();
        }

        function startAnimation() {
            if (animationQueue.length === 0) return;
            isRunning = true;
            runBtn.textContent = '⏸ PAUSE';
            runStep();
        }

        function stopAnimation() {
            isRunning = false;
            runBtn.textContent = '▶ RUN PROCESS';
            if (timer) clearTimeout(timer);
        }

        // --- HANDLERS ---
        part1Btn.onclick = () => {
            currentMode = 1;
            part1Btn.classList.add('active-mode');
            part2Btn.classList.remove('active-mode');
            part1Panel.style.display = 'flex'; // Changed to flex to maintain layout
            part2Panel.style.display = 'none';
            parseAndReset();
        };

        part2Btn.onclick = () => {
            currentMode = 2;
            part2Btn.classList.add('active-mode');
            part1Btn.classList.remove('active-mode');
            part1Panel.style.display = 'none';
            part2Panel.style.display = 'flex'; // Critical: Must be flex for children to grow
            parseAndReset();
        };

        runBtn.onclick = toggleRun;
        stepBtn.onclick = () => {
            stopAnimation();
            runStep();
        };
        resetBtn.onclick = parseAndReset;

        // Modal
        inputBtn.onclick = () => {
            inputModal.classList.add('show');
            modalInputArea.value = isCustom ? rawInput : '';
        };

        closeModalBtn.onclick = () => inputModal.classList.remove('show');

        useExampleBtn.onclick = () => {
            rawInput = EXAMPLE_INPUT;
            isCustom = false;
            localStorage.removeItem('day5_input');
            inputBadge.textContent = 'EX';
            inputBadge.classList.remove('custom');
            inputModal.classList.remove('show');
            parseAndReset();
        };

        useCustomBtn.onclick = () => {
            const val = modalInputArea.value.trim();
            if (val) {
                rawInput = val;
                isCustom = true;
                localStorage.setItem('day5_input', rawInput);
                inputBadge.textContent = 'CUSTOM';
                inputBadge.classList.add('custom');
                inputModal.classList.remove('show');
                parseAndReset();
            }
        };

        // Start
        init();

    </script>
</body>

</html>