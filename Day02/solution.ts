import { readInput } from '../utils';

const exampleInput = readInput('Day02/exampleInput.txt');
const input = readInput('Day02/input.txt');


/**
 * Parse the input to get all ranges
 */
function parseRanges(input: string): Array<{ start: bigint, end: bigint }> {
    const ranges: Array<{ start: bigint, end: bigint }> = [];

    // Split by comma and filter empty entries
    const parts = input.split(',').filter(p => p.trim().length > 0);

    for (const part of parts) {
        const [startStr, endStr] = part.trim().split('-');
        ranges.push({
            start: BigInt(startStr),
            end: BigInt(endStr)
        });
    }

    return ranges;
}

// --------------------------------------------------------------------------------
// Helper: Calculates sum of numbers in an arithmetic progression that fall within [minVal, maxVal]
// Sequence: base * multiplier, (base+1) * multiplier, ...
// We iterate 'base' (half-pattern) range.
// --------------------------------------------------------------------------------
function sumAPInRange(
    minBase: bigint, maxBase: bigint,
    multiplier: bigint,
    rangeStart: bigint, rangeEnd: bigint
): bigint {
    // We want to find range of 'base' such that:
    // rangeStart <= base * multiplier <= rangeEnd

    // Lower bound for base:
    // base >= ceil(rangeStart / multiplier)
    const minValidBase = (rangeStart + multiplier - 1n) / multiplier;

    // Upper bound for base:
    // base <= floor(rangeEnd / multiplier)
    const maxValidBase = rangeEnd / multiplier;

    // Intersect with valid base range [minBase, maxBase]
    const start = minValidBase > minBase ? minValidBase : minBase;
    const end = maxValidBase < maxBase ? maxValidBase : maxBase;

    if (start > end) return 0n;

    const count = end - start + 1n;

    // Sum of bases in [start, end] = n/2 * (start + end)
    const sumOfBases = count * (start + end) / 2n;

    return sumOfBases * multiplier;
}

// --------------------------------------------------------------------------------
// Part 1: Sum "double" numbers (XX) in range.
// --------------------------------------------------------------------------------
function part1(input: string): bigint {
    const ranges = parseRanges(input);
    let totalSum = 0n;

    for (const range of ranges) {
        const startLen = range.start.toString().length;
        const endLen = range.end.toString().length;

        for (let len = startLen; len <= endLen; len++) {
            if (len % 2 !== 0) continue;

            const halfLen = len / 2;
            const minBase = 10n ** BigInt(halfLen - 1);
            const maxBase = 10n ** BigInt(halfLen) - 1n;
            if (halfLen === 1) { // 10^0 = 1, range 1-9
                // Correct.
            }

            // Multiplier to form XX from X: 10^halfLen + 1
            const multiplier = 10n ** BigInt(halfLen) + 1n;

            totalSum += sumAPInRange(minBase, maxBase, multiplier, range.start, range.end);
        }
    }
    return totalSum;
}

// --------------------------------------------------------------------------------
// Part 2: Sum numbers repeating a pattern 2+ times using Inclusion-Exclusion
// --------------------------------------------------------------------------------

// Cache for divisors to avoid recomputing
const divisorsCache = new Map<number, number[]>();
function getProperDivisors(n: number): number[] {
    if (divisorsCache.has(n)) return divisorsCache.get(n)!;
    const divs = [1];
    for (let i = 2; i <= n / 2; i++) {
        if (n % i === 0) divs.push(i);
    }
    divisorsCache.set(n, divs);
    return divs;
}

function part2(input: string): bigint {
    const ranges = parseRanges(input);
    let totalSum = 0n;

    for (const range of ranges) {
        const startLen = range.start.toString().length;
        const endLen = range.end.toString().length;

        for (let len = startLen; len <= endLen; len++) {

            // Map: patternLength -> Sum of Unique numbers generated by that PRIMITIVE pattern length
            const uniqueSums = new Map<number, bigint>();

            // Iterate all divisors of len that are <= len / 2
            // These are valid pattern lengths
            const validPatternLengths = [];
            for (let d = 1; d <= len / 2; d++) {
                if (len % d === 0) validPatternLengths.push(d);
            }

            // We must process smallest lengths first for inclusion-exclusion
            validPatternLengths.sort((a, b) => a - b);

            for (const pLen of validPatternLengths) {
                const minBase = pLen === 1 ? 1n : 10n ** BigInt(pLen - 1);
                const maxBase = 10n ** BigInt(pLen) - 1n;

                // Multiplier: 1 + 10^p + 10^2p ... 
                const reps = len / pLen;
                let multiplier = 0n;
                for (let r = 0; r < reps; r++) {
                    multiplier += 10n ** BigInt(r * pLen);
                }

                // Raw Sum: All numbers generated by patterns of length pLen
                // This includes those generated by sub-patterns (e.g. len 4 includes len 2 repeats)
                let currentSum = sumAPInRange(minBase, maxBase, multiplier, range.start, range.end);

                // Subtract contributions from smaller divisors (make it unique/primitive)
                const properDivs = getProperDivisors(pLen);
                for (const div of properDivs) {
                    if (uniqueSums.has(div)) {
                        currentSum -= uniqueSums.get(div)!;
                        // Note: uniqueSums(div) stores sum of numbers generated by primitive patterns of length div.
                        // These numbers are inherently also generated by length pLen (since div | pLen).
                        // So we subtract them exactly once.
                        // Wait. The numbers generated by length 'div' are P_div * M_div.
                        // The same number viewed as length 'pLen' is P_pLen * M_pLen.
                        // Value is identical. We just subtract the value sum.
                    }
                }

                uniqueSums.set(pLen, currentSum);

                // Add to total
                totalSum += currentSum;
            }
        }
    }
    return totalSum;
}

function run(name: string, input: string) {
    console.log(`--- ${name} ---`);
    console.log('Part 1:', part1(input).toString());
    console.log('Part 2:', part2(input).toString());
}

if (input.length > 0) {
    run('Real Input', input);
}
// Example input might be empty in solution.ts execution context if not handled carefully,
// but let's assume standard flow.
if (exampleInput) run('Example', exampleInput);
