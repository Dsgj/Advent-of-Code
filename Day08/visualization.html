<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advent of Code - Day 08 - Playground</title>
    <link rel="stylesheet" href="../common.css">
    <link rel="stylesheet" href="style.css">

</head>

<body>
    <div class="main-container">
        <!-- Header -->
        <div class="page-header">
            <div class="header-row">
                <a href="../index.html" class="home-link">‚Üê Calendar</a>
                <div class="header-center">
                    <h1>üéÑ STRING LIGHTS üéÑ</h1>
                    <div class="subtitle">Underground Playground ¬∑ Junction Box Network</div>
                </div>
                <div class="header-right">
                    <div class="status-panel-header">
                        <div class="status-light" id="statusLight"></div>
                        <span class="status-text text-glow" id="statusText">RIGGING LIGHTS</span>
                    </div>
                </div>
            </div>
            <div class="header-controls">
                <button id="part1Btn" class="active">Part 1</button>
                <button id="part2Btn">Part 2</button>
                <button id="inputBtn">‚å® Input</button>
            </div>
        </div>

        <!-- Main Content: Canvas + Stats Sidebar -->
        <div class="content-area">
            <!-- 3D Visualization -->
            <div class="viz-panel" id="vizPanel">
                <canvas id="simCanvas"></canvas>
            </div>

            <!-- Stats Sidebar -->
            <div class="stats-sidebar">
                <!-- Status -->
                <!-- Status moved to header -->

                <!-- Stats -->
                <div class="stats-panel">
                    <div class="panel-title">Light Stats</div>
                    <div class="stat-row">
                        <span class="stat-label">üì¶ Boxes</span>
                        <span class="stat-val" id="boxCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">üí´ Wires</span>
                        <span class="stat-val" id="connectionCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">üîó Circuits</span>
                        <span class="stat-val" id="circuitCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">üåü Answer</span>
                        <span class="stat-val gold" id="resultDisplay">0</span>
                    </div>
                </div>

                <!-- Circuit Legend -->
                <div class="stats-panel"
                    style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0;">
                    <div class="panel-title">Circuits</div>
                    <div class="circuit-legend" id="circuitLegend" style="flex: 1; min-height: 0;"></div>
                </div>

                <!-- Controls -->
                <div class="stats-panel">
                    <div class="panel-title">Controls</div>
                    <div class="control-buttons">
                        <button id="runBtn">üí° Wire Up!</button>
                        <button id="stepBtn">‚è≠ Step</button>
                        <button id="resetBtn">üîÑ Reset</button>
                    </div>
                    <div class="speed-control">
                        <label>Speed</label>
                        <input type="range" id="speedSlider" min="1" max="100" value="80">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Input Modal handled by common.js -->

    <script src="../common.js"></script>
    <script>
        const EXAMPLE_INPUT = `162,817,812
57,618,57
906,360,560
592,479,940
352,342,300
466,668,158
542,29,236
431,825,988
739,650,466
52,470,668
216,146,977
819,987,18
117,168,530
805,96,715
346,949,466
970,615,88
941,993,340
862,61,35
984,92,344
425,690,689`;

        let rawInput = EXAMPLE_INPUT;

        // Generate unique colors for each circuit using HSL
        function generateCircuitColor(index, total) {
            const hue = (index * 360 / Math.max(total, 1)) % 360;
            const saturation = 70 + (index % 3) * 10; // 70-90%
            const lightness = 55 + (index % 2) * 10; // 55-65%
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        // Stable color map for circuits (keyed by root)
        let circuitColorMap = new Map();

        // STATE
        // rawInput declared above
        let points = [];
        let pairs = [];
        let uf = null;
        let connectionsMade = 0;
        let targetConnections = 10;
        let isRunning = false;
        let currentMode = 1;
        let lastTime = 0;
        let timeSinceLastStep = 0;
        let tickCounter = 0;

        // 3D rotation
        let rotationY = 0.3;
        let rotationX = 0.2;
        let autoRotate = true;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Canvas
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const vizPanel = document.getElementById('vizPanel');

        // DOM elements
        const boxCountEl = document.getElementById('boxCount');
        const connectionCountEl = document.getElementById('connectionCount');
        const circuitCountEl = document.getElementById('circuitCount');
        const resultDisplay = document.getElementById('resultDisplay');
        const statusTextEl = document.getElementById('statusText');
        const statusLightEl = document.getElementById('statusLight');

        function updateStatus(text, state) {
            statusTextEl.textContent = text;
            statusLightEl.className = 'status-light ' + state;
        }
        const runBtn = document.getElementById('runBtn');
        const speedSlider = document.getElementById('speedSlider');
        const part1Btn = document.getElementById('part1Btn');
        const part2Btn = document.getElementById('part2Btn');


        // Union-Find
        class UnionFind {
            constructor(n) {
                this.parent = Array.from({ length: n }, (_, i) => i);
                this.rank = new Array(n).fill(0);
                this.size = new Array(n).fill(1);
            }

            find(x) {
                if (this.parent[x] !== x) {
                    this.parent[x] = this.find(this.parent[x]);
                }
                return this.parent[x];
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                if (rootX === rootY) return false;

                if (this.rank[rootX] < this.rank[rootY]) {
                    this.parent[rootX] = rootY;
                    this.size[rootY] += this.size[rootX];
                } else if (this.rank[rootX] > this.rank[rootY]) {
                    this.parent[rootY] = rootX;
                    this.size[rootX] += this.size[rootY];
                } else {
                    this.parent[rootY] = rootX;
                    this.size[rootX] += this.size[rootY];
                    this.rank[rootX]++;
                }
                return true;
            }

            getCircuitSizes() {
                const roots = new Set();
                for (let i = 0; i < this.parent.length; i++) {
                    roots.add(this.find(i));
                }
                return Array.from(roots).map(root => this.size[root]);
            }

            getNumCircuits() {
                const roots = new Set();
                for (let i = 0; i < this.parent.length; i++) {
                    roots.add(this.find(i));
                }
                return roots.size;
            }
        }

        function parseInput(input) {
            const lines = input.trim().split(/\r?\n/);
            return lines.map((line, index) => {
                const [x, y, z] = line.split(',').map(Number);
                return { x, y, z, index };
            });
        }

        function distanceSquared(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dz = a.z - b.z;
            return dx * dx + dy * dy + dz * dz;
        }

        function getAllPairDistances(points) {
            const pairs = [];
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    pairs.push({
                        i, j,
                        distSq: distanceSquared(points[i], points[j])
                    });
                }
            }
            return pairs.sort((a, b) => a.distSq - b.distSq);
        }

        // INIT
        function init() {
            const stored = localStorage.getItem('day08_input');
            if (stored) rawInput = stored;
            parseAndReset();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Mouse controls for rotation
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                autoRotate = false;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    rotationY += (e.clientX - lastMouseX) * 0.005;
                    rotationX += (e.clientY - lastMouseY) * 0.005;
                    rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });
            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);

            Common.setupInputModal({
                placeholder: '162,817,812...',
                storageKey: 'day08_input',
                exampleInput: EXAMPLE_INPUT,
                onLoad: (data) => {
                    rawInput = data;
                    localStorage.setItem('day08_input', rawInput);
                    parseAndReset();
                }
            });
            requestAnimationFrame(loop);
        }

        function resizeCanvas() {
            const rect = vizPanel.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        function parseAndReset() {
            stopAnimation();
            points = parseInput(rawInput);
            pairs = getAllPairDistances(points);
            uf = new UnionFind(points.length);
            connectionsMade = 0;

            // Calculate bounds for normalization
            if (points.length > 0) {
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;

                for (const p of points) {
                    minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
                    minZ = Math.min(minZ, p.z); maxZ = Math.max(maxZ, p.z);
                }

                window.dataBounds = {
                    centerX: (minX + maxX) / 2,
                    centerY: (minY + maxY) / 2,
                    centerZ: (minZ + maxZ) / 2,
                    rangeX: (maxX - minX) || 1,
                    rangeY: (maxY - minY) || 1,
                    rangeZ: (maxZ - minZ) || 1
                };
                window.dataBounds.maxRange = Math.max(
                    window.dataBounds.rangeX,
                    window.dataBounds.rangeY,
                    window.dataBounds.rangeZ
                );
            }

            const n = points.length;
            targetConnections = n > 20 ? 1000 : Math.floor(n / 2);

            updateStats();
            updateStatus("Ready to Wire!", "ready");
            runBtn.textContent = 'üí° Wire Up!';
        }

        function loop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            tickCounter++;

            if (autoRotate && !isDragging) {
                rotationY += 0.003;
            }

            if (isRunning) {
                const speedVal = parseInt(speedSlider.value);
                let stepDuration = 500 - (speedVal * 4.5);
                if (speedVal > 90) stepDuration = Math.max(10, 50 - (speedVal - 90) * 4);

                timeSinceLastStep += dt;

                if (timeSinceLastStep >= stepDuration) {
                    stepSimulation();
                    timeSinceLastStep = 0;
                }
            }

            draw();
            requestAnimationFrame(loop);
        }

        function stepSimulation() {
            if (currentMode === 1) {
                if (connectionsMade >= targetConnections || connectionsMade >= pairs.length) {
                    updateStatus("‚ú® All Lit Up!", "complete");
                    stopAnimation();
                    return;
                }

                const pair = pairs[connectionsMade];
                uf.union(pair.i, pair.j);
                connectionsMade++;
            } else {
                if (uf.getNumCircuits() === 1) {
                    updateStatus("üéÑ One Big Circuit!", "complete");
                    stopAnimation();
                    return;
                }

                while (connectionsMade < pairs.length) {
                    const pair = pairs[connectionsMade];
                    if (uf.find(pair.i) !== uf.find(pair.j)) {
                        uf.union(pair.i, pair.j);
                        connectionsMade++;
                        break;
                    }
                    connectionsMade++;
                }
            }

            updateStats();
        }

        function updateStats() {
            boxCountEl.textContent = points.length;
            connectionCountEl.textContent = connectionsMade;
            circuitCountEl.textContent = uf ? uf.getNumCircuits() : points.length;

            if (currentMode === 1) {
                const sizes = uf ? uf.getCircuitSizes().sort((a, b) => b - a) : [];
                const a = sizes[0] || 1;
                const b = sizes[1] || 1;
                const c = sizes[2] || 1;
                resultDisplay.textContent = (a * b * c).toLocaleString();
            } else {
                if (uf && uf.getNumCircuits() === 1 && connectionsMade > 0) {
                    const lastPair = pairs[connectionsMade - 1];
                    const product = points[lastPair.i].x * points[lastPair.j].x;
                    resultDisplay.textContent = product.toLocaleString();
                } else {
                    resultDisplay.textContent = "‚Äî";
                }
            }

            updateCircuitLegend();
        }

        function updateCircuitLegend() {
            const legend = document.getElementById('circuitLegend');
            if (!uf) {
                legend.innerHTML = '';
                circuitColorMap.clear();
                return;
            }

            // Get all circuits with their roots and sizes
            const circuitInfo = [];
            const seen = new Set();
            for (let i = 0; i < points.length; i++) {
                const root = uf.find(i);
                if (!seen.has(root)) {
                    seen.add(root);
                    circuitInfo.push({ root, size: uf.size[root] });
                }
            }
            circuitInfo.sort((a, b) => b.size - a.size);

            // Assign stable colors to circuits
            const totalCircuits = circuitInfo.length;
            circuitInfo.forEach((info, idx) => {
                if (!circuitColorMap.has(info.root)) {
                    circuitColorMap.set(info.root, generateCircuitColor(circuitColorMap.size, Math.max(totalCircuits, 20)));
                }
            });

            // Build legend HTML - show all circuits
            const html = circuitInfo.map((info, i) => {
                const color = circuitColorMap.get(info.root);
                return `<div class="circuit-chip">
                    <div class="circuit-dot" style="background: ${color}; box-shadow: 0 0 4px ${color};"></div>
                    <span>${info.size}</span>
                </div>`;
            }).join('');

            legend.innerHTML = html;
        }

        // 3D projection
        function project(x, y, z) {
            const bounds = window.dataBounds || {
                centerX: 500, centerY: 500, centerZ: 500,
                maxRange: 1000
            };

            const halfRange = bounds.maxRange / 2;
            const nx = (x - bounds.centerX) / halfRange;
            const ny = (y - bounds.centerY) / halfRange;
            const nz = (z - bounds.centerZ) / halfRange;

            const cosY = Math.cos(rotationY);
            const sinY = Math.sin(rotationY);
            const rx = nx * cosY - nz * sinY;
            const rz = nx * sinY + nz * cosY;

            const cosX = Math.cos(rotationX);
            const sinX = Math.sin(rotationX);
            const ry = ny * cosX - rz * sinX;
            const rz2 = ny * sinX + rz * cosX;

            const scale = Math.min(canvas.width, canvas.height) * 0.38;
            const perspective = 2 / (2 + rz2);

            return {
                x: canvas.width / 2 + rx * scale * perspective,
                y: canvas.height / 2 + ry * scale * perspective,
                z: rz2,
                scale: perspective
            };
        }

        function draw() {
            // Background
            const grad = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width * 0.7
            );
            grad.addColorStop(0, '#1a0f25');
            grad.addColorStop(1, '#0a0610');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawStars();


            const getPointColor = (pointIndex) => {
                if (!uf) return 'hsl(0, 70%, 60%)';
                const root = uf.find(pointIndex);
                return circuitColorMap.get(root) || generateCircuitColor(0, 1);
            };

            // Project points
            const projected = points.map(p => ({
                ...project(p.x, p.y, p.z),
                index: p.index,
                original: p
            }));

            projected.sort((a, b) => a.z - b.z);

            // Draw connections
            ctx.lineCap = 'round';
            for (let i = 0; i < connectionsMade && i < pairs.length; i++) {
                const pair = pairs[i];
                const p1 = project(points[pair.i].x, points[pair.i].y, points[pair.i].z);
                const p2 = project(points[pair.j].x, points[pair.j].y, points[pair.j].z);

                const color = getPointColor(pair.i);

                // Glow
                ctx.strokeStyle = color.replace(')', ', 0.25)').replace('hsl', 'hsla');
                ctx.lineWidth = 4 * Math.min(p1.scale, p2.scale);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                // Core
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5 * Math.min(p1.scale, p2.scale);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }

            // Draw nodes
            const baseRadius = points.length > 100 ? 2 : (points.length > 50 ? 3 : 4);
            for (const p of projected) {
                const color = getPointColor(p.index);
                const radius = baseRadius + p.scale * baseRadius;

                if (points.length <= 200) {
                    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 2.5);
                    grad.addColorStop(0, color.replace(')', ', 0.4)').replace('hsl', 'hsla'));
                    grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius * 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawStars() {
            const time = tickCounter * 0.015;
            for (let i = 0; i < 50; i++) {
                const x = ((i * 137.5 + 50) % canvas.width);
                const y = ((i * 73.3 + 30) % canvas.height);
                const alpha = 0.15 + Math.sin(time + i * 0.5) * 0.1;
                const size = 0.5 + (i % 3) * 0.3;

                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function startAnimation() {
            isRunning = true;
            statusTextEl.textContent = currentMode === 0 ? "‚ö° Wiring..." : "üéÑ Lighting Up...";
            statusLedEl.className = 'status-light running';
            runBtn.textContent = '‚è∏ Pause';
        }

        function stopAnimation() {
            isRunning = false;
            runBtn.textContent = 'üí° Wire Up!';
        }

        // Event Listeners
        runBtn.addEventListener('click', () => {
            if (isRunning) stopAnimation();
            else startAnimation();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if (!isRunning) stepSimulation();
        });

        document.getElementById('resetBtn').addEventListener('click', parseAndReset);

        part1Btn.addEventListener('click', () => {
            currentMode = 1;
            part1Btn.classList.add('active-mode');
            part2Btn.classList.remove('active-mode');
            parseAndReset();
        });

        part2Btn.addEventListener('click', () => {
            currentMode = 2;
            part2Btn.classList.add('active-mode');
            part1Btn.classList.remove('active-mode');
            parseAndReset();
        });

        inputBtn.addEventListener('click', () => {
            modalInputArea.value = rawInput;
            inputModal.classList.add('show');
        });

        useExampleBtn.addEventListener('click', () => {
            modalInputArea.value = EXAMPLE_INPUT;
        });

        useCustomBtn.addEventListener('click', () => {
            rawInput = modalInputArea.value;
            localStorage.setItem('day08_input', rawInput);
            inputModal.classList.remove('show');
            parseAndReset();
        });

        closeModalBtn.addEventListener('click', () => {
            inputModal.classList.remove('show');
        });

        init();
    </script>
</body>

</html>